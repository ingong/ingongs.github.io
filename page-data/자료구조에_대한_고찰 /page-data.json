{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/자료구조에_대한_고찰 /",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>TL;DR</h3>\n<ul>\n<li>자료 구조는 왜 사용할까? 어떻게 학습해야할까?</li>\n<li>선형 자료 구조</li>\n<li>5가지 선형 자료 구조 : 배열, 링크드 리스트, 스택, 큐, 해쉬 테이블</li>\n</ul>\n<h2>자료 구조는 왜 사용할까?</h2>\n<p>해당 질문에 대해서 너무 추상적인 블로그 글 들이 많았기 때문에 자료 구조의 정의를 먼저 찾아봤다. 자료 구조는 데이터의 집합에 효율적인 <code class=\"language-text\">접근</code>과, <code class=\"language-text\">수정</code>을 위해 데이터를 구분하여 표현하는 방법이다. 그렇다면 왜 효율적으로 접근하고 수정해야할까?</p>\n<p>최근에 학습했던 프로그래밍 언어의 기본 패러다임에서 이유를 추론해봤다. 프로그래밍 언어의 기본 패러다임 중 하나는 변수에 값을 저장하고, 저장된 값을 가져오고, 저장된 값을 수정하는 것이다. 이를 통해 프로그램에서 상태를 나타날 수 있다. 여기서 변수는 상태를 가지며, 위에 문단에서 언급한 데이터를 가진 식별자가 된다.</p>\n<p>정리해보면 자료구조는 프로그래밍 언어의 패러다임 중 하나인 변수에 대한 효율적인 접근과 수정을 구현하기 위한 방법이라고 할 수 있다. 많은 변수들에 접근해야할 필요가 있기 때문에 이 변수를 모아두고, 이 변수의 사용 목적에 맞게 구성한다면 효율성을 향상시킬 수 있을 것이다. 너무 당연한 이야기지만 나만의 언어로 풀어내기는 어려운 개념이라고 생각해 정리했다.</p>\n<h2>자료구조를 어떻게 학습해야할까?</h2>\n<p>자료구조가 왜 필요한지를 학습하고 나니 어떻게 학습할지에 대한 방법에도 감을 잡을 수 있었다. 데이터를 활용하기 위한 목적을 잘 정의해야 적합한 자료 구조를 선택할 수 있다고 생각한다. 일상 생활에서 활용되는 데이터를 예시로 생각해보자. 데이터는 어떤 구조들을 갖는가? 머릿 속에 떠오르는 구조에 대한 예시는 ‘학교 조회 시간에서 번호 순으로 줄서기’ 와 ‘상하관계가 명확했던 군대의 조직도’ 이다.</p>\n<p>번호 순으로 줄을 세우는 방법에는 어떤 장점이 있을까? 아마 ‘원하는 번호에 대한 학생을 쉽게 찾을 수 있다’ 와 ‘학생들을 운동장에 집합시킬 때 규칙을 부여할 수 있다’ 정도가 있을 것 같다. 이렇게 학생들의 상태를 구조화하려면 컴퓨터에서는 어떤 자료구조를 사용해야할까? 바로 <code class=\"language-text\">선형 자료 구조</code> 를 사용하면 된다.</p>\n<h2>선형 자료 구조</h2>\n<p><code class=\"language-text\">선형 자료 구조</code>는 저장되는 데이터의 전후 관계가 1 : 1 인 자료구조 라고 할 수 있다. 그러면 왜 순차적으로 나열해야하는지 궁금해졌다. 구글링을 한 결과 컴퓨터 메모리가 선형으로 배열되어 있어 구현이 쉽다는 이유를 찾을 수 있었다. 이는 충분한 이유가 됐다. 그렇다면 왜 메모리는 선형으로 배열되어있을까? 이 부분은 메모리에 대해 공부 해야한다고 생각해서 나름 심리학에서 배웠던 내용들로 추론해보았다.</p>\n<p>당연한 이야기일지 모르지만 사람은 항상 다양한 문제에 직면하고, 이 문제를 해결한다. 이 문제를 해결하기 위해서 우리는 그 문제의 원인을 찾고, 그 원인에 대한 원인을 또 찾으려고 한다. 아마 ‘이 A의 원인은 B이고, B의 원인은 C 이고, C 의 원인은 D이다’ 이런 식의 기계적인 사고를 하지는 않겠지만, 우리는 무의식적으로 아마 위와과 같은 순서로 문제의 원인을 찾았을 것이다. 다음과 같은 사고 방식을 <code class=\"language-text\">선형적 사고</code>라고 한다. 물론 모든 문제를 선형적 사고로 해결할 수는 없겠지만, 우리는 그 문제를 선형적 사고방식으로 해결하려고 했을 것이다. 메모리도 결국 사람이 만들었기 때문에 이러한 사고가 적용되지 않았을까라고 조심스럽게 추측해본다.</p>\n<p>선형 자료 구조를 사용하는 이유가 충분했다고 가정하고, 이제는 어떻게 사용할지에 대해서 알아보도록 하자. 선형 자료구조는 크게 배열, 링크드 리스트, 스택, 큐, 해쉬 테이블이 있다. 아까 자료구조를 공부하는 방법에 대한 문단에서 데이터를 어떤 목적으로 사용하는지 정의하고, 그 자료구조를 학습하기로 했었다. 따라서 5가지 자료구조에 대해서 각각 데이터의 활용 목적이 무엇이며, 기본적으로 알아야 하는 내용에 대해서 다뤄보겠다.</p>\n<h2>배열 (Array)</h2>\n<p>동일한 데이터 타입의 값들을 연속적으로 저장할 때 배열을 사용한다. 인간은 선형적 사고에 대해 편안함을 느끼기 때문에 이 자료구조는 우리의 사고 방식과도 유사해서 편안한 마음을 갖고 사용할 수 있다. 배열은 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 우리는 인덱스로 해당 원소에 접근할 수 있다. 즉, 찾고자 하는 인덱스를 알고 있으면 O(1) 로 해당 원소에 접근할 수 있다.</p>\n<p>접근이 용이하다는 장점이 있지만 연속적인 원소 삽입과 삭제의 경우에는 비효율적일 수 있다. 삽입의 경우 시간 복잡도가 O(1)이 지만, 연속적으로 n 의 크기만큼 삽입을 하려고 한다면 O(n) 의 시간 복잡도가 소요된다. 또한 배열의 맨 앞에 원소를 삽입하는 경우 기존에 있던 원소들의 index 를 1씩 증가시켜야하고, 시간 복잡도는 O(n) 이다.</p>\n<p>배열의 원소를 삭제하는 경우에도 배열의 연속적인 특징이 깨지게 된다. 배열은 그 순서를 유지하기 위해 추가적인 작업을 해야 하고 비용이 발생한다. 삭제한 원소보다 큰 인덱스를 갖는 원소들을 <code class=\"language-text\">shift</code> 해줘야하고, 이 경우 시간 복잡도는 O(n) 이 된다.</p>\n<h2>링크드 리스트 (Linked List)</h2>\n<p>이 삽입과 삭제 시 발생하는 비효율을 해결하기 위해 등장한 자료구조가 링크드 리스트이다. 선형적으로 원소를 저장하되, 삽입과 삭제의 비효율을 감소시키기 위해 등장했다. 링크드 리스트에서 각각의 원소들은 자기 자신 다음에 어떤 원소가 존재하는지 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 모두 O(1) 만에 해결할 수 있다.</p>\n<p>하지만 링크드 리스트 역시 하나의 문제가 있다. 원하는 위치에 삽입하고자 한다면 위치를 탐색하는 비용이 발생한다. 원하는 위치를 탐색하는 과정에서 첫 번째 위치부터 하나씩 다 찾아야한다. 이 과정 때문에 O(n) 의 시간이 발생한다. 결국 링크드 리스트는 탐색, 삽입, 삭제 모두 O(n) 의 시간 복잡도를 갖는다. 링크드 리스트의 필요성에 대해 느끼지 못할 수 있지만, 다음 시간에 학습할 비선형 자료 구조 중 트리의 근간이 되는 자료구조이기 때문에 알아두는 편이 좋다.</p>\n<p>배열과 링크드 리스트 모두 저장되는 데이터의 전후 관계가 1 : 1로 선형 자료구조이지만, 배열은 논리적 저장 순서와 물리적 저장 순서가 동일한 반면, 링크드 리스트는 논리적 저장 순서와 물리적 저장 순서가 다르다. 배열은 메모리 할당시 연속적인 데이터 공간 할당이 일어나지만, 링크드 리스트는 비연속적인 데이터 공간 할당이 일어난다.</p>\n<h2>스택 (Stack)</h2>\n<p>스택은 나중에 들어가는 원소를 우선적으로 꺼내야할 때 사용되는 자료 구조이다. Last In First Out (LIFO) 라는 키워드로 충분히 설명될 것 같다. 먼저 들어간 원소는 바닥에 깔리고, 나중에 들어가는 원소는 그 위에 차곡차곡 쌓이는 구조이다. 삽입에 대해 O(1) 이 소요되고, 마지막 원소를 삭제할 때 O(1) 이 소요된다.</p>\n<h2>큐 (Queue)</h2>\n<p>큐는 스택과 반대로 먼저 들어가는 원소를 우선적으로 꺼내야할 때 사용되는 자료구조다. 이는 Frist In First Out (FIFO) 라는 키워드로 설명될 수 있다.</p>\n<h2>해쉬 테이블 (Hash Table)</h2>\n<p>해쉬 테이블은 <code class=\"language-text\">(key, value)</code> 로 데이터를 저장하는 자료구조 중 하나로, 빠르게 데이터를 검색하기 위한 용도로 사용된다. 해시 테이블은 어떻게 빠르게 데이터를 검색하는지 궁금했다. 찾아보니 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문이라고 한다. 배열에 대한 내용을 다뤘던 문단에서 우리는 index 를 알고 있다면 O(1) 로 접근할 수 있다는 사실을 알 수 있었다. 그렇다면 배열과의 차이점은 무엇이 있을까?</p>\n<p>해쉬 테이블이 내부적으로 배열로 구현되었기 때문에 당연히 index 를 가지며, 이 index 를 정의하는 방법에 있어서 배열과 차이가 있었다. 배열은 물리적 순서를 기반으로 논리적 순서가 결정되었다. 즉, 삽입되는 순서를 보장하면서 데이터에 대한 연속적인 메모리 공간할당이 이루어진다. 하지만 해쉬 테이블은 해쉬 함수를 통해 고유한 index 를 생성하고, 이 index 를 활용해 값을 저장하거나 검색한다. 그리고 해쉬 테이블에서는 실제 값이 저장되는 공간을 배열이 아닌, 버켓(bucket) 또는 슬롯이라고 부른다.</p>\n<p>해쉬 테이블에서 주목할 점은 이 고유의 index 를 부여하는 과정에 있다. 이 과정은 특별한 알고리즘으로 구현되었으며, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없다. 따라서 연산에 의한 추가적인 비용이 발생하지 않고, 평균 시간 복잡도는 O(1) 을 가진다.</p>\n<p>시간 복잡도면 시간 복잡도지, 평균 시간 복잡도라고 부르는 이유는 무엇일까? 이 이유는 이 특별한 알고리즘을 알아보면 자연스럽게 알 수 있게 된다. 이 특별한 알고리즘을 우리는 <code class=\"language-text\">hash method</code> 또는 <code class=\"language-text\">해시 함수(hash function)</code> 이라고 한다. 또한 이 메소드에 의해 반환된 고유의 index 를 <code class=\"language-text\">hashcode</code> 라고 한다. 해쉬 함수는 저장되는 값들의 key 값을 작은 범위의 값들로 바꿔준다. 특정한 범위가 존재한다면 당연히 key 값에 대해 <code class=\"language-text\">Collision(충돌)</code> 이 발생할 수 있다. <code class=\"language-text\">Collision</code> 이란 서로 다른 두 개의 키가 같은 <code class=\"language-text\">hashcode</code> 로 해싱되어 같은 곳에 저장할 수 없는 상황을 의미한다.</p>\n<p>이 충돌을 최소한으로 하기 위해서는 <code class=\"language-text\">hash function</code> 을 잘 정의해야한다. 일반적으로 좋은 <code class=\"language-text\">hash function</code> 은 키의 일부분이 아닌, 키 전체를 참조하여 해쉬 값을 만들어낸다. 또한 좋은 해쉬 함수는 키가 어떤 특성을 가지고 있느냐에 대해서도 달라지게 된다. <code class=\"language-text\">hash function</code>를 무조건 1:1 로 만드는 것보다 Collision 을 최소화하는 방향으로 설계하고 발생하는 Collision 에 대비해 어떻게 대응할 것인가가 더 중요하다. 1:1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런 <code class=\"language-text\">hash function</code>를 만들어봤자 그건 array 와 다를바 없고 메모리를 너무 차지하게 된다.</p>\n<p><code class=\"language-text\">Collision</code> 이 많아질 수록 탐색에 필요한 시간복잡도가 O(1)에서 O(n)에 가까워진다. 어설픈 <code class=\"language-text\">hash function</code>는 hash 를 hash 답게 사용하지 못하도록 한다. 좋은 <code class=\"language-text\">hash function</code>를 선택하는 것은 hash table 의 성능 향상에 필수적인 것이다. 따라서 hashing 된 인덱스에 이미 다른 값이 들어 있다면 새 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수이며 그 방법들에 대해 알아보자.</p>\n<h2>Resolve Conflict</h2>\n<p>해쉬 테이블에서는 충돌 문제를 분리 연결법(Separate Chaining) 과 연결 주소법(Open Addressing) 로 해결한다.</p>\n<h3>1. 개방 주소법 (Open Addressing)</h3>\n<p>개방 주소법(Open Addressing) 은 해쉬 테이블의 공간을 활용하는 방법이다. 이 방법은 충돌이 발생하면 데이터를 저장할 장소를 찾아 해맨다. Worst Case 의 경우 비어있는 버킷을 찾지 못하고, 탐색을 시작한 위치까지 되돌아 올 수 있다. <strong>개방 주소법</strong>을 구현하는 방법에는 크게 3가지가 있다.</p>\n<ul>\n<li>Linear Probing: 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.</li>\n<li>Quadratic Probing: 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.</li>\n<li>Double Hashing Probing: 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.</li>\n</ul>\n<div align=\"center\">\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 637px; flex:1.2519685039370079;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/a740a244038bf86287f220fedc047ca6/a82f2/OpenAddressing.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 79.87421383647799%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y4VUiY6iQBT0/39pNlk2nhzKoayykUSjAh4RUPHW2tRzYFzGme2ENLzmVderet2V+/2O8ijH8m/O+VNez58KA9frFdkuw3w+x+Fw+BY0H+fzGePxGG7PxWg0KuIVgvX7faitFjRNQzCbycLtdvsExtjxeBQC3Ny2LKiqiq7TlXWuVdI0hWVZqNdqAhgGwZeABIqiCJPJBGEQotNuQ1EUdNodxOsY0+n0AejYDgzDgK7rCEqAz/pxrNdrJHGCMAxh2zZqtRrMTqf4p5Imiejg+z4c2y4Ay7o9A14uF2FKEr8URUovADebjZRMLZrNJvzhEKvVCsvl8h8Hc9bzKBL9ojCUPOYYuvHEME1lh0ajgWajgT+eJwz2+/0nQIlnmbzPZjO4risydR1HNisY0qW2YQhLz/O+Lfl0OslMhpqq4cfbG7zBQAC54YOhbaNerwtLLpZNeTYmZ06tHceRnN+uK2DvpqRiBvXQVBX+0C8Ayw6zmVkqW4Stw3Z5tE37Q8M4jkVDQ9fFteBFH746KXTZNE1Uq9VCJuZU2N29bg+tVgvKT0VcfFVqORa+l0ypCFwA8mXQHwhtNms58auLg2eeVVmmie12+1EyXWMgyzIkaYLdbvcS9PmbOewOGpTns1K5HAgkZzMM5dZYLBb/BSQQtWYOTw5ndgsB/wI7KL4fhQsuPgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/a740a244038bf86287f220fedc047ca6/75c88/OpenAddressing.webp 159w,\n/static/a740a244038bf86287f220fedc047ca6/4ac49/OpenAddressing.webp 319w,\n/static/a740a244038bf86287f220fedc047ca6/bfe67/OpenAddressing.webp 637w,\n/static/a740a244038bf86287f220fedc047ca6/e6861/OpenAddressing.webp 956w,\n/static/a740a244038bf86287f220fedc047ca6/77061/OpenAddressing.webp 1274w,\n/static/a740a244038bf86287f220fedc047ca6/fa3b0/OpenAddressing.webp 1358w\" sizes=\"(max-width: 637px) 100vw, 637px\" type=\"image/webp\">\n          <source srcset=\"/static/a740a244038bf86287f220fedc047ca6/c3678/OpenAddressing.png 159w,\n/static/a740a244038bf86287f220fedc047ca6/759af/OpenAddressing.png 319w,\n/static/a740a244038bf86287f220fedc047ca6/90cda/OpenAddressing.png 637w,\n/static/a740a244038bf86287f220fedc047ca6/78204/OpenAddressing.png 956w,\n/static/a740a244038bf86287f220fedc047ca6/0ba95/OpenAddressing.png 1274w,\n/static/a740a244038bf86287f220fedc047ca6/a82f2/OpenAddressing.png 1358w\" sizes=\"(max-width: 637px) 100vw, 637px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/a740a244038bf86287f220fedc047ca6/90cda/OpenAddressing.png\" alt=\"OpenAddressing\" title=\"OpenAddressing\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n</div>\n<h3>2. 분리 연결법 (Separate Chaining)</h3>\n<div align=\"center\">\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 637px; flex:1.5288461538461537;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5a90a7a98f49132ab8fa5a412f997661/f09c0/SeparateChaining.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 65.40880503144655%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACv0lEQVQ4y12T228bRRSH/f9WAvEAhSd4gz4CT0AqLortOGmRk2I3UBEp9S1IbROwXaeOvSR7X7veeL2z3t1Zrz+0XpMi5uiTjs4ZnZkzc34FgDRN8YUgjCLWwHq9JrMsHoURQgiCIGC9tVW6whc+3sJDJvIunllhUzBJuFYUJrbNvwdkSyYRI+WSfr+PZVnkySwBlmqhjlUiP8rj65xCdpso30MMROv1Jp9IyZVi8Kx1zvHFb9iORfWySlkvU7wqUhqV2NcOqNxU2B3u8v3gB8bemMIS+NSb877jcE9TeRAIiCVzz+XVhUa5ekHxxT62azFdTtGXOpqvoQd6jsjRAh0hBYXsZrUk4SAMqQjBszRlYTukyQqZxhhTFXtqEy0jTpQTakaNY/OYmlbnqfF042ccqU/QhE4hBB5EIZ/MZtyfOHwZx8gggChmsVww0ob0R30M3aDxZ4O/pl36sz69aY+++5r+LKf7tstteEshe7eKlDx0XXb8BT/H+SOnb2eYpUc0PviQ706/Zh4taI1bnBqntM02LaNFU2/SmZxt/Of6cybLSV5wL0nYmc/5drHgcZIQuLfMbIOz0zfsPWzyTWeHeThn6A1p2E06doe21aZptDib/kHb7tAwGnnBrOUvfJ+PHYePZjO+EoK5ZSF8HyFDLg2F1+MBhq7TM3sMvAFdp0t30mVwO9i03Zv03rWcfUpdSh75PgdC8HsicV2XMAxJ0hhzcoPlmPmnXJ9Qs+scKUccKkfUzfqGJ9e/cHhziOpr+dh8Fi55T9e4p97w+TJASonnubw4VylXzym93Mdx7buxsSILMzQ3GIGxIRulQAbvBjvcsp17kkRy9bfJr42X1F8dY5gG1ctDKmaF4lWJ3WGRirrP3nWF0qjMj29+QlkoufTI1PEf1lu1ZDqLV0uiMORurbbyS//np7n0/gGl6rSgpK+MfwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/5a90a7a98f49132ab8fa5a412f997661/75c88/SeparateChaining.webp 159w,\n/static/5a90a7a98f49132ab8fa5a412f997661/4ac49/SeparateChaining.webp 319w,\n/static/5a90a7a98f49132ab8fa5a412f997661/bfe67/SeparateChaining.webp 637w,\n/static/5a90a7a98f49132ab8fa5a412f997661/f3677/SeparateChaining.webp 940w\" sizes=\"(max-width: 637px) 100vw, 637px\" type=\"image/webp\">\n          <source srcset=\"/static/5a90a7a98f49132ab8fa5a412f997661/c3678/SeparateChaining.png 159w,\n/static/5a90a7a98f49132ab8fa5a412f997661/759af/SeparateChaining.png 319w,\n/static/5a90a7a98f49132ab8fa5a412f997661/90cda/SeparateChaining.png 637w,\n/static/5a90a7a98f49132ab8fa5a412f997661/f09c0/SeparateChaining.png 940w\" sizes=\"(max-width: 637px) 100vw, 637px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/5a90a7a98f49132ab8fa5a412f997661/90cda/SeparateChaining.png\" alt=\"SeparateChaining\" title=\"SeparateChaining\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n</div>\n<p><code class=\"language-text\">분리 연결법(Separate Chaining)</code> 은 동일한 버킷의 데이터에 대해 자료구조를 활용하고, 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 방법이다. 위의 그림과 같이 동일한 버킷으로 접근한다면 데이터들을 연결해서 해결해준다. 분리 연결법은 해시 테이블의 확장이 필요없고, 구현과 삭제가 쉽다. 하지만 데이터의 수가 많아지면 동일한 버킷에 대해 chaining 되는 데이터가 많아져, 캐시의 효율이 감소한다는 단점이 있다. 활용하는 자료구조는 링크드 리스트와 트리가 있다. 두 가지 자료구조를 활용하는 방식에 대한 설명은 다음과 같다.</p>\n<ul>\n<li><strong>링크드 리스트를 사용하는 방식(Linked List)</strong>\n각각의 버킷(bucket)들을 연결리스트(Linked List)로 만들어 Collision 이 발생하면 해당 bucket 의 list 에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 비해 테이블의 확장을 늦출 수 있다.</li>\n<li><strong>Tree 를 사용하는 방식 (Red-Black Tree)</strong>\n연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 데이터의 개수가 적다면 링크드 리스트를 사용하는 것이 맞다. 트리는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst Case 를 살펴보면 트리와 링크드 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용한다.</li>\n<li>위 두가지 방식에 대한 선택 기준은 <code class=\"language-text\">하나의 해쉬 버켓에 할당된 key-value 쌍의 개수</code> 이다. 적은 경우에는 링크드 리스트를 사용하고, 많은 경우에는 트리를 사용한다. 적고 많고의 기준은 key-value 쌍의 개수를 기준으로 6개, 8개이다. 왜 6개와 8개인지에 대한 설명은 다음과 같다.\n<strong><em>데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?</em></strong> 앞에서 말했듯이 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 이 키-값 쌍의 개수가 6 개, 8 개를 기준으로 결정한다. 기준이 두 개 인것이 이상하게 느껴질 수 있다. 7 은 어디로 갔는가? 링크드 리스트의 기준과 트리의 기준을 6 과 8 로 잡은 것은 변경하는데 소요되는 비용을 줄이기 위함이다.\n<strong><em>한 가지 상황을 가정해보자.</em></strong> 해시 버킷에 <strong>6 개</strong> 의 key-value 쌍이 들어있었다. 그리고 하나의 값이 추가되었다. 만약 기준이 6 과 7 이라면 자료구조를 링크드 리스트에서 트리로 변경해야 한다. 그러다 바로 하나의 값이 삭제된다면 다시 트리에서 링크드 리스트로 자료구조를 변경해야 한다. 각각 자료구조로 넘어가는 기준이 1 이라면 Switching 비용이 너무 많이 필요하게 되는 것이다. 그래서 2 라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6 개에서 7 개로 증가했을 때는 링크드 리스트의 자료구조를 취하고 있을 것이고 8 개에서 7 개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다.</li>\n</ul>\n<h3>두 가지 방식에 대해 비교를 해보면 다음과 같다.</h3>\n<p>개방 주소법(Open Addressing) 은 분리 연결법(Separate Chaining) 에 비해 느리다. 개방 주소법의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 높다. 하지만 분리 연결법의 경우 보조 해시 함수를 통해 조정한다면 충돌의 확률을 낮출 수 있다.</p>\n<p>두 방식 모두 Worst Case 에서 O(M)이다. 하지만 개방 주소법(Open Addressing)방식은 연속된 공간에 데이터를 저장하기 때문에 <code class=\"language-text\">분리 연결법(Separate Chaining)</code>에 비해 캐시 효율이 높다. 따라서 데이터의 개수가 충분히 적다면 개방 주소법(Open Addressing) 방식이 <code class=\"language-text\">분리 연결법(Separate Chaining)</code>보다 더 성능이 좋다.</p>\n<p>또한 <code class=\"language-text\">분리 연결법(Separate Chaining)</code> 은 버킷을 계속 사용하지 않기 때문에 테이블의 확장을 늦출 수 있다.\n<br>\n<br>\n<br></p>","frontmatter":{"title":"자료구조에 대한 고찰과 선형 자료구조","summary":"해당 질문에 대해서 너무 추상적인 블로그 글 들이 많았기 때문에 자료 구조의 정의를 먼저 찾아봤다. 자료 구조는 데이터의 집합에 효율적인 `접근`과, `수정`을 위해 데이터를 구분하여 표현하는 방법이다. 그렇다면 왜 효율적으로 접근하고 수정해야할까? 이 고민을 하면서 자료구조에 대해 학습하고, 선형 자료구조에 대해서 학습했다.","date":"2021.12.23.","categories":["CS"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/d7f738a87cd2e8d6afe7a9806f704187/ba9d9/test.png","srcSet":"/static/d7f738a87cd2e8d6afe7a9806f704187/1f45a/test.png 120w,\n/static/d7f738a87cd2e8d6afe7a9806f704187/f9aa0/test.png 240w,\n/static/d7f738a87cd2e8d6afe7a9806f704187/ba9d9/test.png 479w","sizes":"(min-width: 479px) 479px, 100vw"},"sources":[{"srcSet":"/static/d7f738a87cd2e8d6afe7a9806f704187/a884e/test.webp 120w,\n/static/d7f738a87cd2e8d6afe7a9806f704187/1235d/test.webp 240w,\n/static/d7f738a87cd2e8d6afe7a9806f704187/75872/test.webp 479w","type":"image/webp","sizes":"(min-width: 479px) 479px, 100vw"}]},"width":479,"height":400.99999999999994}},"publicURL":"/static/d7f738a87cd2e8d6afe7a9806f704187/test.png"}}}}]}},"pageContext":{"slug":"/자료구조에_대한_고찰 /"}},
    "staticQueryHashes": []}