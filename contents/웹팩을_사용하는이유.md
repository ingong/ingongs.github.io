---
date: '2021-11-02'
title: '웹팩은 왜 사용하는가'
categories: ['개발환경']
summary: '이번 프로젝트에서 우리 팀은 CRA 없이 밑바닥부터 Webpack 과 Babel 을 설정하면서 프로젝트를 구성하였다. 스프린트 때부터 웹팩을 하나씩 설정하면서 프로젝트를 진행했었고, 현업에 갔을 때 웹팩 설정을 따로 할일은 없다고 이야기를 들었지만, 우리가 원하는 최적화를 진행하려면 우리가 설정한 결과를 이해할 필요가 있다고 판단했다.'
thumbnail: './test.png'
---

이번 포스트에서는 우리 팀이 왜 CRA 를 사용하지 않고 Webpack 을 사용했는지에 대한 이유와 Webpack 의 주요 속성에 대해서 이야기해보려한다.

### TL;DR

- Webpack 은 효율적인 모듈 시스템 활용과 코드 스플리팅을 통한 로딩 성능 향상을 위해 사용된다.
- Webpack 은 웹 개발 작업을 자동화할 수 있는 도구이다.

## Webpack

<div align="center">
<img src="https://w.namu.la/s/cff859aa600201bd726c9c550f0d147077bda195be1c22e51df2ab812d1089b0868997e25b2626949461b9974a3ec9f804fe3798caa9244c0466ca9ac35c98a104a25c3aecf4df4940883d2abdabca89af52e9f8a5a2071589610c25526af41b7535da1e4ac9191423e5a2db72a668eb" width="600">
</div>
<br/>
<br/>

### Webpack 을 사용한 이유

Webpack 은 JS 모듈 번들러이기 때문에 현 FE 생태계에서 사용하지 않는 것은 불가능하다. 물론 CRA 도 웹팩 기반이기 때문에 CRA 를 써도 웹팩을 사용하는 것이다.
우리 팀은 따라서 당연히 사용하는 것이 아니라 왜 우리가 웹팩을 써야하는지 조사하고 정리해보았다. 그 이유는 크게 3가지로 요약된다.

- 효율적인 모듈 시스템 활용
- 코드 스플리팅을 통한 로딩 성능 향상
- 여러 로더를 통해 하나의 파일 또는 여러 개의 묶음 파일로 만드는 과정을 통해 웹 브라우저가 서버로 요청하는 파일의 갯수 감소
- 웹팩에서 BundleAnalyzerPlugin 을 활용해서 번들 사이즈 측정

다음으로는 Webpack 의 주요 속성에 대해서 알아보자.
<br/>
<br/>

### Webpack 의 4가지 주요 속성

웹팩의 빌드 과정을 이해하기 위해서는 아래 4가지 주요 속성에 대해 알고 있어야한다.

#### 1) entry

`entry` 속성은 웹팩에서 웹 자원을 변환하기 위해 필요한 최초 진입점이자 자바스크립트 파일 경로이다.

```js
// webpack.config.js
module.exports = {
  entry: './src/index.js',
};
```

웹팩을 실행했을 때 src 폴더 내의 index.js 를 대상으로 빌드를 수행하겠다고 웹팩에게 알려주는 것이다. 엔트리 포인트는 1개 일수도, 여러 개일 수도 있다. 엔트리 포인트를 분리하는 경우에는 싱글페이지 어플리케이션이 아닌 특정 페이지 진입 시 서버에서 해당 정보를 받는 멀티 페이지 어플리케이션에 적합하다.

#### 2) output

`output` 속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미한다.
filename 을 지정해야하며, 일반적으로 `output` 이 만들어진 경로와 함께 정의한다.

```jsx
// webpack.config.js
const path = require('path');

module.exports = {
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, './dist'),
  },
};
```

#### 3) loader

웹팩이 웹 애플리케이션을 해석할 때 자바스크립트 파일이 아닌 웹 자원들을 변환할 수 있도록 도와주는 속성이다. 로더는 파일을 해석하고 변환하는 과정에 관여한다.

```js
// webpack.config.js
module.exports = {
  module: {
    rules: [],
  },
};
```

module 이라는 이름을 사용하며, 사용할 loader 를 rules 라는 배열에 추가하는 형식으로 활용한다.
다음은 우리팀이 작성한 webpack loader 설정 코드이다.

```js
  module: {
    rules: [
      {
        test: /\.(ts|tsx)$/,
        loader: 'babel-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.(png|jp(e)g|gif|svg)$/,
        type: 'asset/resource',
      },
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/,
        type: 'asset',
        parser: {
          dataUrlCondition: {
            maxSize: 8 * 1024,
          },
        },
      },
    ],
  },
```

사용한 3가지 loader 에 대해서 간단하게 설명해보겠다.

1. babel-loader <br />
   ts 와 tsx 는 babel-loader 를 통해 transpile 과 polyfill 된다. 따라서 ts-loader 를 별도로 사용하지 않고, babel-loader 만 사용했다.
   <br/>
   <br/>
2. asset/resource <br />
   webpack 5 이전에는 raw-loader, url-loader, file-loader 를 사용했지만 webpack 5 부터는 새로운 모듈 유형이 추가됐다. 관련한 설명은 webpack 의 asset-modules 공식 문서를 통해서 자세하게 학습할 수 있다. asset/resource 는 별도의 파일을 내보내고 URL 을 추출하는 모듈이다. 이전에는 file-loader 를 사용하여 처리할 수 있었다.
   <br/>
   <br/>
3. asset <br />
   local-font 를 사용하기 때문에 글꼴에 대한 처리도 해주어야했다. asset 모듈은 data URI와 별도의 파일 내보내기 중에서 자동으로 선택한다. 우리가 준 maxSize 속성은 8KB 기준이며 그 크기가 넘어가지 않는다면 asset/inline 모듈을 사용한다.
   <br/>

#### 4) plugin

plugin은 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성이다. 빌드한 결과물의 형태를 바꾸는 역할을 한다고 보면 된다.
plugin은 다음과 같이 선언한다.

```js
// webpack.config.js
module.exports = {
  plugins: [],
};
```

우리팀이 설정한 Webpack plugin 속성은 다음과 같다.

```js

const HtmlWebpackPlugin = require('html-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

//...
plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
      minify:
        process.env.NODE_ENV === 'production'
          ? {
              collapseWhitespace: true,
              removeComments: true,
            }
          : false,
    }),
    new BundleAnalyzerPlugin(),
  ],
```

- HtmlWebpackPlugin <br/>
  웹팩으로 빌드한 결과물로 HTML 파일을 생성해주는 플러그인이다.
- BundleAnalyzerPlugin <br/>
  빌드할 경우에 BundleSize 를 가시적으로 보여주는 플러그인이다.
  아직 개발환경설정 단계라 JS 번들 사이즈를 줄일 것이 없지만 이후에 해당 플러그인을 활용해 번들사이즈를 줄여볼 예정이다.

## 마무리

Webpack 을 사용하는 이유와 주요 속성에 대해서 정리해보았다. 이외에도 별칭 설정과데 개발 환경에서 사용할 Webpack devserver 도 설정했는데 별도로 다루지는 않았다. 해당 내용은 웹팩 핸드북이나 웹팩 공식 문서에 잘 나와있으니 참고하면 좋을 것 같다.

웹팩은 기본적으로 코드 스플리팅을 통한 로딩 성능향상을 지원한다. React 에서는 lazy 라는 키워드만 활용한다면 해당 하는 컴포넌트와 페이지를 lazy 하게 import 할 수도 있다. 이를 통해서 사용자가 처음 진입하는 페이지에서의 번들 사이즈를 줄이고, 좀 더 빠른 로딩 속도를 기대할 수 있다.
