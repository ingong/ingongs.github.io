---
date: '2021-10-12'
title: 'FE 상태관리 - 상태관리의 대상과 구조'
categories: ['FE']
summary: '부스트캠프 Web23팀 프로젝트인 협업은 애자일 방법론으로 프로젝트를 진행할 때 발생하는 이슈(에픽, 스토리, 테스크) 를 관리하기 위한 협업툴이다. 우리는 상태 관리의 복잡도를 낮추고, 좋은 UX 를 제공하자는 목표를 세웠다. 이번 글에서는 상태 관리에 대한 우리의 고민을 작성해보려 한다'
thumbnail: './test.png'
---

### TL;DR

- 부스트캠프 Web23팀 프로젝트인 협업은 애자일 방법론으로 프로젝트를 진행할 때 발생하는 이슈(에픽, 스토리, 테스크) 를 관리하기 위한 협업툴이다.
- 상태 관리의 대상에 대한 고민을 통해 에픽, 스토리, 테스크 중 테스크를 제외했다.
- 기존 상태 관리의 구조였던 중첩 구조를 분리했다.

## 우리 팀의 고민

부스트캠프의 그룹 프로젝트를 하면서 가장 신경 썼던 있는 부분은 우리가 하고 있는 학습에 대한 과정을 기록하는 것이다. 고민과 해결에 대한 내용을 기록하면서 우리의 사고 과정을 기록하고, 우리의 의견을 명확한 힘을 가지게 된다고 생각했다.

이번 주에 마무리한 HyupUp 은 애자일 방법론으로 프로젝트를 진행할 때 발생하는 이슈 관리를 위한 협업 툴이다. 사용자는 하나의 조직에 가입할 수 있으며, 그 조직에는 여러 개의 프로젝트가 존재하는 구조이다. 프로젝트에는 에픽, 스토리, 테스크의 순서로 계층구조를 이루는 상태가 존재한다. 사용자는 프로젝트를 만들고, 해당 프로젝트에 에픽을 추가할 수 있다. 또한 스토리를 추가한 다음 어떤 에픽에 포함되게 할지 드롭다운을 통해 선택할 수 있다. 스토리 모달에서는 테스크를 추가하고 테스크를 팀원에게 할당시킬 수 있다. 그리고 마지막으로 이 3가지 기능이 모두 다른 사용자들에게 실시간으로 반영되는 기능을 목표로 세웠다.

우리는 위 기능들을 구현하기 전에, 복잡해보이는 3가지 데이터(에픽, 스토리, 테스크)를 어떻게 잘 관리할지에 대한 고민을 시작했다. 먼저 '3가지 데이터를 모두 프론트엔드에서 상태로 관리해야하는가?' 에 대한 주제로 의견을 나눴다. 실시간으로 반영되기 위해서는 상태로 관리해야한다는 의견이 있었다. 반대로 테스크는 데이터 양이 크고 복잡도를 키울 수 있어 제외하자는 의견도 있었다.

## 상태 관리의 대상

논의 끝에 우리는 테스크를 상태에서 제외하기로 결정했다. 크게 2가지 이유를 도출했다.

첫 번재는 관리하기가 번거롭고, 동기화의 필요성이 낮았기 때문이다. 우리 서비스의 페이지는 크게 홈페이지(개인이 테스크를 관리), 프로젝트 페이지(프로젝트 전체에 대한 이슈 관리, 테스트도 포함) 로 구성되어있다. 만약 상태관리를 한다면 한 페이지 내에서의 변화를 다른 페이지에서도 즉각 반영해야했다. 프로젝트를 진행할 때, 테스크와 같은 작은 단위의 이슈를 실시간으로 반영해야할 필요는 없어보였다. 테스크의 상태들에 기반하여 스토리가 변하지도 않았고, 프로젝트 페이지에서는 스토리 아이템을 클릭해야 테스크가 보였기 때문에 굳이..? 라는 생각을 가지게 되었다. 따라서 우리는 테스크를 상태관리의 대상에서 제외시키는 첫 번째 이유를 도출했다.

두 번째는 테스크 관리의 성격이 SPA 에 적합하지 않았다. SPA 는 웹사이트의 전체 페이지를 나의 페이지에 담아 동적으로 화면을 바꿔가면서 표현한다. 즉, User 의 액션에 따라서 필요한 데이터를 업데이트해서 사용자에게 보여주는 상황에 적합한 어플리케이션이다. 하지만 Task 의 경우에는 사용자의 동작에 따라 다른 상태를 보여주지 않고, 기존에 있는 Task 를 보여주는 경우가 더 많다. 오히려 상태로 갖고 있기 보다는 캐싱을 통해 반복되는 API 호출을 효율적으로 관리하는 편이 낫다고 생각했다.

우리는 다음 2가지의 이유로 Task 를 상태관리의 대상에서 제외시켰다. 사용자의 Task 를 한 번에 보여주는 메인페이지에 대해서는 오히려 서버 사이드 렌더링을 도입도 고려해볼만하다고 생각했다. 하지만 테스크의 상위 개념인 스토리와 에픽의 경우는 상태로 관리해야했고, 우리의 개발 리소스는 한정적이였기 때문에 상태관리의 대상에서 제외시키는 선택으로 만족했다.

## 상태 관리 구조

### 초기 상태 관리 구조

```jsx
{
	"project": {
		"epics": [{ "stories": [{ "tasks": [{ ... }, { ... }, { ... }],}, { ... }, { ... }], }, { ... }, { ... }],
		"anoterEpics": [{ "stories": [{ "tasks": [{ ... }, { ... }, { ... }],}, { ... }, { ... }], }, { ... }, { ... }]
	},
	"anotherproject": {
		"epics": [{ "stories": [{ "tasks": [{ ... }, { ... }, { ... }],}, { ... }, { ... }], }, { ... }, { ... }],
		"anoterEpics": [{ "stories": [{ "tasks": [{ ... }, { ... }, { ... }],}, { ... }, { ... }], }, { ... }, { ... }]
	},
	...
}
```

에픽 → 스토리 → 태스크의 위계구조를 가지는 구조이기 때문에 에픽 안에 스토리가 있고, 스토리 안에 태스크가 들어가 있는 중첩된 자료구조를 가질 수도 있다. 또한 에픽, 스토리, 태스크를 따로 따로 가지고 있을 수도 있다. 지금보면 정말 말도 안되는 구조이지만, 그 당시에는 치열하게 고민해서 도출해낸 결과이다.

### 개선한 상태 관리 구조

```tsx
// epic
{
	"project":[{epics}, {anotherEpics}],
	"anotherProject":[{epics}, {anotherEpics}],
}

// story
{
	"project":[{story}, {otherstory}, ...],
	"anotherproject":[{story}, {otherstory}, ...],
}

// task
{
	"project":[{task}, {othertask}, ...],
	"anotherproject":[{task}, {othertask}, ...],
}
```

projectId 를 키로 가지고 있고 배열로 관리해야했기 때문에 하나의 상태(에픽, 스토리 또는 테스크) 를 수정하려고 한다면 이 배열들을 전부 수정해야만 했다. 또한 여전히 depth 가 2이기 때문에 복잡해보였다. 상태를 추가하고, 수정하고, 삭제하는게 어려워보였다. 따라서 조금 더 나은 상태 구조에 대한 고민이 필요했다.

### 최종 상태 관리 구조

```tsx
// epicList
[{ epic }, { epic }, { epic }, { epic }, { epic }];

// epic
type EpicType = {
  id: number;
  projectId: number;
  name: string;
  startAt: Date;
  endAt: Date;
  order: number;
};

// storyList
[{ story }, { story }, { story }, { story }, { story }, { story }];

// story
type StoryType = {
  id: number;
  projectId: number;
  epicId: number;
  name: string;
  status: StoryStatusType;
  order: number;
};
```

최종으로 결정한 상태 관리구조이다. 에픽 배열을 따로, 스토리 배열을 따로 관리하기로 하였다. 우리가 계층 구조를 고민한 이유가 상위 상태가 하위 상태의 변화에 따라 변화할 필요가 있기 때문이였다. 배열로 상태 관리 구조를 변경하면서 각각 개별 상태에 상위 상태에 대한 id 를 부여하기로 했다.

## 마무리

6주간 우리는 이 상태를 씹고, 뜯고, 맛 보았다. 우리 프로젝트의 목표는 실시간 상태 관리였다. 한 사용자의 상태 변화가 다른 사용자가 새로고침하지 않아도 실시간으로 반영되게 하였고, 소켓과 API 를 적절히 활용해서 구현할 수 있었다. 실시간으로 상태를 반영하다보니, 불필요한 상태가 함께 자주 변경된다면 사용자 입장에서도 불편함을 느낄 수 있을 것이라고 생각했다. 이 고민들을 해결하기 위해 상태 관리의 대상과 구조를 고민했고 해결했다. 우리의 선택에 대한 근거를 제시하자는 목표로 논의를 시작했는데, 문제도 해결하고 근거도 만들 수 있었던 과정이였던 것 같다.
